<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.557">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-09-07">

<title>Tom Savage - Tiny Bayesian Optimisation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script type="module" src="../../site_libs/quarto-ojs/quarto-ojs-runtime.js"></script>
<link href="../../site_libs/quarto-ojs/quarto-ojs.css" rel="stylesheet">


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Tom Savage</span>
    </a>
  </div>
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../portfolio.html"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About Me</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
</div>
            <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Tiny Bayesian Optimisation</h1>
            <p class="subtitle lead">High-performance BO in under 100 lines.</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 7, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="bo.gif" class="img-fluid figure-img"></p>
<figcaption>This GIF was made with only 100 lines of vanilla Python + Numpy + Matplotlib.</figcaption>
</figure>
</div>
<p>There is a Bayesian optimisation gold-rush, and everyone is selling shovels. Bayesian optimisation is core to the concept of self-driving labs, automated drug-discovery, and many other modern research topics. It’s well motivated, and a very useful tool. Start ups are being founded and <a href="https://www.merckgroup.com/en/news/opensource-ai-experimentation-planner-06-12-2023.html">pharmaceutical</a> and <a href="https://github.com/experimental-design/bofire">chemicals</a> companies are curating teams that focus fundamentally on Bayesian optimisation in one way or another. As a result, there is now a growing number of libraries, ranging from black-box APIs and no-code solutions to statistically accurate fine-grained representations; each becoming more bloated as new functionalities or usecases are appended.</p>
<p>With all of these options, each with their own special definition of a <code>dataset</code>, or a <code>kernel</code>, or an <code>acquisition_function</code>, or otherwise, it becomes difficult to see the wood for the trees. Someone in my group recently asked me if it was reasonably possible to implement Bayesian optimisation, and I more often than not get asked what library or package I use.</p>
<p>It is obviously important that BO tools become widely available, particularly to those that don’t know how to code, or don’t have the time such as chemists or industrial engineers. But the trade-off is that students, and practitioners are potentially using something that they don’t understand, and investors may be hoodwinked into investing in something that seems more complex than it is.</p>
<p>My mission in this post is to demonstrate that, whilst Bayesian optimisation entails a lot of moving parts, <em>implementing</em> it from scratch really shouldn’t take too long.</p>
<p>To make my point, I am going to code everything required for Bayesian optimisation, <em>including visualisation</em>… in under 100 lines of standard Python and Numpy. This will include a custom metaheuristic-based optimisation algorithm, Gaussian processes from scratch with trainable hyperparameters, an acquisition function, and an experimental design loop.</p>
<p>First, I’ll give myself some groundrules:</p>
<section id="rules" class="level3 cleanbox">
<h3 class="anchored" data-anchor-id="rules">Rules</h3>
<p><br> <br></p>
<ol start="0" type="1">
<li>Bayesian Optimisation that is competetive with established packages;</li>
<li>Python Standard Library + Numpy only;</li>
<li>Simple as possible;</li>
<li>Code <strong>must</strong> be interpretable.</li>
</ol>
</section>
<p>To begin with I’ll implement a Gaussian process from scratch.</p>
<section id="gaussian-processes" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="gaussian-processes">Gaussian processes</h3>
<p>Now I’ll need a kernel function that defines how related two points are in input space. I’ll go for the Matern 5/2. I’m not choosing it because it’s differentiable<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, but rather because I think samples from the prior will look most like functions I’m interested in.</p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;This is an attractive property of Gaussian processes that is ultimately distracting when optimising as a result of their nonconvexity, as I’ll cover later.</p></div></div><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> k(x1,x2,p): <span class="co">#&nbsp;squared exponential kernel</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    sigma,l <span class="op">=</span> p[<span class="dv">0</span>],p[<span class="dv">1</span>] <span class="co">#&nbsp;hyperparameters</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> np.sqrt(np.dot(x1<span class="op">-</span>x2,x1<span class="op">-</span>x2))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigma<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> np.sqrt(<span class="dv">5</span>)<span class="op">*</span>d<span class="op">/</span>l <span class="op">+</span> <span class="dv">5</span><span class="op">*</span>d<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(<span class="dv">3</span><span class="op">*</span>l<span class="op">**</span><span class="dv">2</span>)) <span class="op">*</span> np.exp(<span class="op">-</span>np.sqrt(<span class="dv">5</span>)<span class="op">*</span>d<span class="op">/</span>l)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Simple enough. Forget the hyperparameters now, I’ll cover those later. Now, I’ll give myself the ability to calculate a covariance matrix. I only need to calculate the kernel function for the upper triangular, then symmetrically set the corresponding lower triangular value to be the same<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, saving me some time.</p>
<div class="no-row-height column-margin column-container"><div id="fn2"><p><sup>2</sup>&nbsp;Because all valid covariance matrices are positive semi-definite.</p></div></div><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cm(x,p): <span class="co"># covariance matrix</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> x.shape[<span class="dv">0</span>]<span class="op">;</span> K <span class="op">=</span> np.zeros((n,n))</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i,n): <span class="co">#&nbsp;symmetric</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            K[i,j] <span class="op">=</span> K[j,i] <span class="op">=</span> k(x[i],x[j],p)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> K <span class="op">+</span> <span class="fl">1e-6</span><span class="op">*</span>np.ones(n)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I’ve added some jitter to the diagonal just to help out when inverting the matrix in a bit. This is relatively common across all Gaussian process libraries. The final GP utility I’ll require is the negative log-likelihood, which will be used to assess hyperparameter performance.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nll(p, x, y): <span class="co"># negative log likelihood</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> cm(x, p) <span class="co"># calculate covariance matrix</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> (np.log(la.det(K)) <span class="op">+</span> (y <span class="op">-</span> p[<span class="dv">2</span>]).T <span class="op">@</span> la.solve(K, y <span class="op">-</span> p[<span class="dv">2</span>]) <span class="op">+</span> <span class="bu">len</span>(x) <span class="op">*</span> np.log(<span class="dv">2</span> <span class="op">*</span> np.pi))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now everything needed has been defined, I’ll create my Gaussian process class. I will simplify the training procedure by making it train on instanciation. The only other thing that is needed is the ability to call it, returning the mean and variance of the posterior distribution at x.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GP: <span class="co">#&nbsp;Gaussian process class</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,x,y):</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> x<span class="op">;</span> <span class="va">self</span>.y <span class="op">=</span> y</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># optimize hyperparameters (sigma, l, constant mean)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.p <span class="op">=</span> tiny_opt(partial(nll, x<span class="op">=</span>x, y<span class="op">=</span>y), np.array([[<span class="fl">0.1</span>,<span class="fl">10.0</span>],[<span class="fl">0.1</span>,<span class="fl">10.0</span>],[np.<span class="bu">min</span>(y),np.<span class="bu">max</span>(y)]]))</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.K_inv <span class="op">=</span> la.inv(cm(x,<span class="va">self</span>.p)) <span class="co">#&nbsp;precompute inverse covariance matrix</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>,x): </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        k_row <span class="op">=</span> np.array([[k(x,xi,<span class="va">self</span>.p) <span class="cf">for</span> xi <span class="kw">in</span> <span class="va">self</span>.x]]) <span class="co">#&nbsp;compute row of covariance matrix</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        dot_prod <span class="op">=</span> np.dot(k_row,<span class="va">self</span>.K_inv) <span class="co">#&nbsp;precompute dot product</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.p[<span class="dv">2</span>] <span class="op">+</span> dot_prod.dot(<span class="va">self</span>.y<span class="op">-</span><span class="va">self</span>.p[<span class="dv">2</span>]).item(), <span class="op">\</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            k(x,x,<span class="va">self</span>.p) <span class="op">-</span> np.dot(dot_prod,k_row.T).item()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It is defined by data x and y (both row-wise Numpy arrays). I have a mysterious function called <code>tiny_opt</code> which for now provides us with optimal hyperparameters with respect to the negative log-likelihood. This ‘training’ step, and the precompution of the inverse of the covariance matrix<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> defines a ‘trained’ Gaussian process. I’ve never really liked that terminology, borrowed from neural network training<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. One of these parameters is a constant that defines my mean function. As a result of this, combined with the kernel lengthscale parameter, there is now no need to deal with data normalisation. <a href="https://sav.phd/posts/noisy_bo">I’ve previously covered noisy Bayesian optimisation</a>, but as I won’t be dealing with noisy observations here, my GP is noiseless.</p>
<div class="no-row-height column-margin column-container"><div id="fn3"><p><sup>3</sup>&nbsp;Resulting in the <em>precision matrix</em>.</p></div><div id="fn4"><p><sup>4</sup>&nbsp;Though when creating sparse Gaussian processes, the specification of hyperparameters does look more akin to training neural network parameters.</p></div></div><p>Next up, I’ll outline what is actually happening in my <code>tiny_opt</code> function. This will also eventually be used to optimise my acquisition function as well so it’s worth getting right.</p>
</section>
<section id="metaheuristic-optimisation" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="metaheuristic-optimisation">Metaheuristic Optimisation</h3>
<p>As I previously mentioned, I see the ability to easily calculate the gradient of a Gaussian process largely as a distraction. I am relatively confident that most people who have any significant experience optimising Gaussian processes will agree. In addition, BO can potentially be made unusually inefficient when using a gradient-based optimiser due to <strong>flat</strong> regions within an acqusition function, leading to functions such as <a href="https://arxiv.org/abs/2310.20708">logEI being proposed</a>.</p>
<p>Gaussian processes, or resulting functions that apply them<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> are generally nonconvex. Whilst local minima can be overcome, it’s clear that even in one dimension, there are often as many local optima as data points.</p>
<div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;Such as acquisition/utility functions (spoiler).</p></div></div><p>Gaussian processes are practically free to evaluate in the grand scheme of experimental design, and most practical problems are interval-constrained. Combined with the fact that they can of course be evaluted in parallel, motivates the use of evaluation hungry but effective metaheuristics.</p>
<p>I myself have found them very effective in optimising acqusition functions, and was pleased to see Google’s internal GP optimisation algorithm taking a similar view when they <a href="https://arxiv.org/abs/2408.11527v1">recently released details</a>.</p>
<p>My algorithm is self-documented but I will describe it below. I’ve found it to be simple and effective. I wouldn’t even describe it as a metaheuristic. Actually, I will.</p>
<p>Every time you refresh this page my algorithm will be named after a different completely arbitrary animal!</p>
<div class="cell">
<div class="sourceCode cell-code hidden" id="cb5" data-startfrom="126" data-source-offset="-0"><pre class="sourceCode js code-with-copy"><code class="sourceCode javascript" style="counter-reset: source-line 125;"><span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a>animals <span class="op">=</span> [</span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Lion"</span><span class="op">,</span> <span class="st">"Elephant"</span><span class="op">,</span> <span class="st">"Giraffe"</span><span class="op">,</span> <span class="st">"Zebra"</span><span class="op">,</span> <span class="st">"Penguin"</span><span class="op">,</span></span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Kangaroo"</span><span class="op">,</span> <span class="st">"Koala"</span><span class="op">,</span> <span class="st">"Panda"</span><span class="op">,</span> <span class="st">"Tiger"</span><span class="op">,</span> <span class="st">"Dolphin"</span><span class="op">,</span></span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Octopus"</span><span class="op">,</span> <span class="st">"Flamingo"</span><span class="op">,</span> <span class="st">"Cheetah"</span><span class="op">,</span> <span class="st">"Gorilla"</span><span class="op">,</span> <span class="st">"Sloth"</span><span class="op">,</span></span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Platypus"</span><span class="op">,</span> <span class="st">"Rhinoceros"</span><span class="op">,</span> <span class="st">"Crocodile"</span><span class="op">,</span> <span class="st">"Owl"</span><span class="op">,</span> <span class="st">"Chameleon"</span><span class="op">,</span></span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Toucan"</span><span class="op">,</span> <span class="st">"Meerkat"</span><span class="op">,</span> <span class="st">"Hedgehog"</span><span class="op">,</span> <span class="st">"Jellyfish"</span><span class="op">,</span> <span class="st">"Lemur"</span></span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a>descriptive_words <span class="op">=</span> [</span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Swarming"</span><span class="op">,</span> <span class="st">"Running"</span><span class="op">,</span> <span class="st">"Leaping"</span><span class="op">,</span> <span class="st">"Crawling"</span><span class="op">,</span> <span class="st">"Swimming"</span><span class="op">,</span></span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Flying"</span><span class="op">,</span> <span class="st">"Pouncing"</span><span class="op">,</span> <span class="st">"Slithering"</span><span class="op">,</span> <span class="st">"Galloping"</span><span class="op">,</span> <span class="st">"Diving"</span><span class="op">,</span></span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Soaring"</span><span class="op">,</span> <span class="st">"Burrowing"</span><span class="op">,</span> <span class="st">"Climbing"</span><span class="op">,</span> <span class="st">"Gliding"</span><span class="op">,</span> <span class="st">"Hopping"</span><span class="op">,</span></span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Sprinting"</span><span class="op">,</span> <span class="st">"Meandering"</span><span class="op">,</span> <span class="st">"Prowling"</span><span class="op">,</span> <span class="st">"Stalking"</span><span class="op">,</span> <span class="st">"Charging"</span><span class="op">,</span></span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Darting"</span><span class="op">,</span> <span class="st">"Scurrying"</span><span class="op">,</span> <span class="st">"Lumbering"</span><span class="op">,</span> <span class="st">"Prancing"</span><span class="op">,</span> <span class="st">"Scampering"</span><span class="op">,</span></span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Waddling"</span><span class="op">,</span> <span class="st">"Zigzagging"</span><span class="op">,</span> <span class="st">"Fluttering"</span><span class="op">,</span> <span class="st">"Paddling"</span><span class="op">,</span> <span class="st">"Swooping"</span><span class="op">,</span></span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Lunging"</span><span class="op">,</span> <span class="st">"Grazing"</span><span class="op">,</span> <span class="st">"Perching"</span><span class="op">,</span> <span class="st">"Hovering"</span><span class="op">,</span> <span class="st">"Circling"</span><span class="op">,</span></span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Nesting"</span><span class="op">,</span> <span class="st">"Foraging"</span><span class="op">,</span> <span class="st">"Hunting"</span><span class="op">,</span> <span class="st">"Bounding"</span><span class="op">,</span> <span class="st">"Swinging"</span><span class="op">,</span></span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Lounging"</span><span class="op">,</span> <span class="st">"Basking"</span><span class="op">,</span> <span class="st">"Roosting"</span><span class="op">,</span> <span class="st">"Migrating"</span><span class="op">,</span> <span class="st">"Hibernating"</span><span class="op">,</span></span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Camouflaging"</span><span class="op">,</span> <span class="st">"Molting"</span><span class="op">,</span> <span class="st">"Preening"</span><span class="op">,</span> <span class="st">"Frolicking"</span><span class="op">,</span> <span class="st">"Stampeding"</span></span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<div id="ojs-cell-1-1" data-nodetype="declaration">

</div>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<div id="ojs-cell-1-2" data-nodetype="declaration">

</div>
</div>
</div>
</div>
<p>Introducing the…</p>
</section>
<section id="descriptive_wordsmath.floormath.random-descriptive_words.length-animalsmath.floormath.random-animals.length-algorithm" class="level1 page-columns page-full">
<h1><span><span id="ojs-element-id-1"></span></span> <span><span id="ojs-element-id-2"></span></span> Algorithm!</h1>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tiny_opt(f,b): <span class="co"># small metaheuristic optimization</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> np.mean(b, axis<span class="op">=</span><span class="dv">1</span>)<span class="op">;</span> b_og <span class="op">=</span> b.copy()</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    b_f <span class="op">=</span> <span class="op">-</span>np.inf<span class="op">;</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">=</span> <span class="dv">1</span> <span class="co"># track best solution, count stagnation, and shrink factor</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(b)): <span class="co"># shrink search space around current centre by w</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> (b[i,<span class="dv">1</span>] <span class="op">-</span> b[i,<span class="dv">0</span>]) <span class="op">*</span> w</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            b[i] <span class="op">=</span> [c[i] <span class="op">-</span> r <span class="op">/</span> <span class="dv">2</span>, c[i] <span class="op">+</span> r <span class="op">/</span> <span class="dv">2</span>]</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># generate random solutions within search space</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.clip(ra.rand(<span class="dv">1000</span>,<span class="bu">len</span>(b))<span class="op">*</span>(b[:,<span class="dv">1</span>]<span class="op">-</span>b[:,<span class="dv">0</span>])<span class="op">+</span>b[:,<span class="dv">0</span>], b_og[:,<span class="dv">0</span>], b_og[:,<span class="dv">1</span>])</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> Pool() <span class="im">as</span> pool: <span class="co"># evaluate solutions in parallel</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> pool.<span class="bu">map</span>(f, x)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        sol <span class="op">=</span> x[np.argmax(y)] <span class="co"># best solution</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> f(sol) <span class="op">&gt;</span> b_f: <span class="co"># if improvement, update best solution</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            b_f <span class="op">=</span> f(sol)<span class="op">;</span> c <span class="op">=</span> sol<span class="op">;</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">=</span> <span class="fl">0.75</span> <span class="co"># shrink search space next time</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co"># if no improvement, don't shrink search space next time (set w = 1)</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span> w <span class="op">=</span> <span class="dv">1</span> <span class="co"># increment stagnation counter</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (b_og[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">-</span>b_og[<span class="dv">0</span>,<span class="dv">0</span>])<span class="op">/</span>(b[<span class="dv">0</span>,<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>,<span class="dv">1</span>]) <span class="op">&lt;</span> <span class="fl">0.25</span> <span class="kw">or</span> count <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            <span class="co"># if search space has shrunk below a threshold or not shrunk for 3 iterations</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> c <span class="co"># return best solution!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Simply, I sample solutions within the bounds and evaluate them in parallel. If I sample the best overall solution I store this, and shrink the bounds around this point. I then re-sample and repeat. If I don’t find a better solution I don’t shrink the bounds. If I don’t find a better solution for three iterations I terminate. I also terminate if the bounds shrink below a certain threshold. These two properties ensure that the algorithm terminates eventually<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>. It is effectively a global trust-region method.</p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;Empirically</p></div></div><p>Here’s a little visualisation that I’ve drawn.</p>
<p><img src="explanation.jpg" class="img-fluid"></p>
<p>With the ability to optimise functions, all I need is an acquisition function, which is simple enough… and a loop!</p>
<p>This is just the expected improvement of a Gaussian process, implemented by importing <code>NormalDist</code> from the <code>statistics</code> standard library.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ei(gp,x): <span class="co"># expected improvement</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    mu, var <span class="op">=</span> gp(x)<span class="op">;</span> N <span class="op">=</span> NormalDist()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> (mu <span class="op">-</span> np.<span class="bu">max</span>(gp.y)) <span class="op">/</span> np.sqrt(var)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sqrt(var) <span class="op">*</span> (z <span class="op">*</span> N.cdf(z) <span class="op">+</span> N.pdf(z))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>And here is my loop…</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>bounds <span class="op">=</span> np.array([[<span class="op">-</span><span class="fl">10.0</span>,<span class="fl">10.0</span>]]) </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    gp <span class="op">=</span> GP(x, y) <span class="co"># build GP</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    x_opt <span class="op">=</span> tiny_opt(partial(ei,gp),bounds)<span class="op">;</span> y_opt <span class="op">=</span> ei(gp,x_opt) <span class="co"># optimise aq</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.vstack([x,x_opt]) <span class="co"># update x</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.vstack([y,np.array([f(x_opt[<span class="dv">0</span>])])]) <span class="co"># evaluate and update y</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>… that’s it!</p>
<p>But to really prove that this works, I’m going to even choose an interesting test function to use, and implement the ability to visualise 1D functions<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<div class="no-row-height column-margin column-container"><div id="fn7"><p><sup>7</sup>&nbsp;Note that all of the above works for any dimensional function.</p></div></div><section id="plotting" class="level3">
<h3 class="anchored" data-anchor-id="plotting">Plotting</h3>
<p>To plot my package to see it it is working, I’ll need a test function. One of my personal favourite ways of doing this is to sample one from a GP prior:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>x_gp <span class="op">=</span> np.linspace(bounds[<span class="dv">0</span>,<span class="dv">0</span>],bounds[<span class="dv">0</span>,<span class="dv">1</span>],<span class="dv">100</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> cm(x_gp, [<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">0.0</span>])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>y_gp <span class="op">=</span> ra.multivariate_normal(np.zeros(<span class="bu">len</span>(x_gp)), K).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>f_gp <span class="op">=</span> GP(x_gp,y_gp)<span class="op">;</span> f <span class="op">=</span> <span class="kw">lambda</span> x: f_gp(x)[<span class="dv">0</span>] <span class="co"># this now acts as my 'true' function</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>An easy way of doing this is by drawing from a multivariate distribution with given covariance matrix and training a GP using this data. This provides a continuous, callable random function without dealing with things like pseudorandom number generation.</p>
<p>I’ve written before about plotting practices (<a href="https://sav.phd/posts/plots/">here</a> and <a href="https://sav.phd/posts/trajectory_plots/">here</a>), so I won’t go into too much detail. Here is the code that evaluates the GP and acqusition function and plots them both.</p>
<p>In addition, I save each plot and produce a GIF at the end.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(bounds[<span class="dv">0</span>,<span class="dv">0</span>],bounds[<span class="dv">0</span>,<span class="dv">1</span>],<span class="dv">3</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)  <span class="co"># initial training data</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.array([f(xi) <span class="cf">for</span> xi <span class="kw">in</span> x]).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="co"># initial training data</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    x_test <span class="op">=</span> np.array([xi <span class="cf">for</span> xi <span class="kw">in</span> np.linspace(bounds[<span class="dv">0</span>,<span class="dv">0</span>],bounds[<span class="dv">0</span>,<span class="dv">1</span>],<span class="dv">200</span>)]).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="co"># test data</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    images <span class="op">=</span> []</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">16</span>):</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        gp <span class="op">=</span> GP(x, y) <span class="co">#&nbsp;create GP</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        x_opt <span class="op">=</span> tiny_opt(partial(ei,gp),bounds)<span class="op">;</span> y_opt <span class="op">=</span> ei(gp,x_opt)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        mu, var <span class="op">=</span> np.array([gp(xi) <span class="cf">for</span> xi <span class="kw">in</span> x_test]).T<span class="op">;</span> std <span class="op">=</span> np.sqrt(var)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        fig,ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">3</span>),sharex<span class="op">=</span><span class="va">True</span>,constrained_layout<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].set_xlabel(<span class="st">'$x$'</span>)<span class="op">;</span> ax[<span class="dv">0</span>].set_ylabel(<span class="st">'$f(x)$'</span>)<span class="op">;</span> ax[<span class="dv">1</span>].set_ylabel(<span class="st">'EI(x)'</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>].scatter(x,y,c<span class="op">=</span><span class="st">'k'</span>,marker<span class="op">=</span><span class="st">'x'</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>].plot(x_test, mu,c<span class="op">=</span><span class="st">'k'</span>)<span class="op">;</span> ax[<span class="dv">0</span>].plot(x_gp, y_gp,c<span class="op">=</span><span class="st">'k'</span>,ls<span class="op">=</span><span class="st">'--'</span>,alpha<span class="op">=</span><span class="fl">0.5</span>,label<span class="op">=</span><span class="st">'True Function'</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>].fill_between(x_test.flatten(), mu<span class="op">-</span>std, mu<span class="op">+</span>std, alpha<span class="op">=</span><span class="fl">0.25</span>,lw<span class="op">=</span><span class="dv">0</span>,color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(x_test, [ei(gp,xi) <span class="cf">for</span> xi <span class="kw">in</span> x_test],c<span class="op">=</span><span class="st">'k'</span>,label<span class="op">=</span><span class="st">'Expected Improvement'</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].scatter(x_opt,y_opt,c<span class="op">=</span><span class="st">'k'</span>,marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> ax: </span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            a.spines[<span class="st">'top'</span>].set_visible(<span class="va">False</span>)<span class="op">;</span> a.spines[<span class="st">'right'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>            a.set_yticks([])</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>            a.legend(loc<span class="op">=</span><span class="st">'upper center'</span>,bbox_to_anchor<span class="op">=</span>(<span class="fl">0.5</span>,<span class="fl">1.1</span>),frameon<span class="op">=</span><span class="va">False</span>,ncol<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        filename <span class="op">=</span> <span class="ss">f'</span><span class="sc">{</span>_<span class="sc">:03d}</span><span class="ss">.png'</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        plt.savefig(filename,dpi<span class="op">=</span><span class="dv">300</span>)<span class="op">;</span> plt.close()</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        images.append(Image.<span class="bu">open</span>(filename))</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.vstack([x,x_opt]) <span class="co"># update x </span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> np.vstack([y,np.array([f(x_opt[<span class="dv">0</span>])])]) <span class="co"># evaluate and update y</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    images[<span class="dv">0</span>].save(<span class="st">'bo.gif'</span>,save_all<span class="op">=</span><span class="va">True</span>,append_images<span class="op">=</span>images[<span class="dv">1</span>:],duration<span class="op">=</span><span class="dv">500</span>,loop<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The full code is here, approximately 20% of the lines are for plotting!</p>
<details>
<summary>
Click to view all code.
</summary>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np<span class="op">;</span> <span class="im">import</span> numpy.linalg <span class="im">as</span> la<span class="op">;</span> <span class="im">import</span> numpy.random <span class="im">as</span> ra</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> multiprocessing <span class="im">import</span> Pool<span class="op">;</span> <span class="im">from</span> statistics <span class="im">import</span> NormalDist</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial<span class="op">;</span> <span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt<span class="op">;</span> <span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> k(x1,x2,p): <span class="co">#&nbsp;squared exponential kernel</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    sigma,l <span class="op">=</span> p[<span class="dv">0</span>],p[<span class="dv">1</span>] <span class="co">#&nbsp;hyperparameters</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> np.sqrt(np.dot(x1<span class="op">-</span>x2,x1<span class="op">-</span>x2))</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sigma<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> np.sqrt(<span class="dv">5</span>)<span class="op">*</span>d<span class="op">/</span>l <span class="op">+</span> <span class="dv">5</span><span class="op">*</span>d<span class="op">**</span><span class="dv">2</span><span class="op">/</span>(<span class="dv">3</span><span class="op">*</span>l<span class="op">**</span><span class="dv">2</span>)) <span class="op">*</span> np.exp(<span class="op">-</span>np.sqrt(<span class="dv">5</span>)<span class="op">*</span>d<span class="op">/</span>l)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cm(x,p): <span class="co"># covariance matrix</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> x.shape[<span class="dv">0</span>]<span class="op">;</span> K <span class="op">=</span> np.zeros((n,n))</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i,n): <span class="co">#&nbsp;symmetric</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            K[i,j] <span class="op">=</span> K[j,i] <span class="op">=</span> k(x[i],x[j],p)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> K <span class="op">+</span> <span class="fl">1e-3</span><span class="op">*</span>np.eye(n)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nll(p, x, y): <span class="co"># negative log likelihood</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> cm(x, p) <span class="co"># calculate covariance matrix</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> (np.log(la.det(K)<span class="op">+</span><span class="fl">1e-6</span>) <span class="op">+</span> (y <span class="op">-</span> p[<span class="dv">2</span>]).T <span class="op">@</span> la.solve(K, y <span class="op">-</span> p[<span class="dv">2</span>]) <span class="op">+</span> <span class="bu">len</span>(x) <span class="op">*</span> np.log(<span class="dv">2</span> <span class="op">*</span> np.pi))</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tiny_opt(f,b): <span class="co"># small metaheuristic optimization</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> np.mean(b, axis<span class="op">=</span><span class="dv">1</span>)<span class="op">;</span> b_og <span class="op">=</span> b.copy()</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    b_f <span class="op">=</span> <span class="op">-</span>np.inf<span class="op">;</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">=</span> <span class="dv">1</span> <span class="co"># track best solution, count stagnation, and shrink factor</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(b)): <span class="co"># shrink search space around current centre by w</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> (b[i,<span class="dv">1</span>] <span class="op">-</span> b[i,<span class="dv">0</span>]) <span class="op">*</span> w</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>            b[i] <span class="op">=</span> [c[i] <span class="op">-</span> r <span class="op">/</span> <span class="dv">2</span>, c[i] <span class="op">+</span> r <span class="op">/</span> <span class="dv">2</span>]</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># generate random solutions within search space</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.clip(ra.rand(<span class="dv">10</span>,<span class="bu">len</span>(b))<span class="op">*</span>(b[:,<span class="dv">1</span>]<span class="op">-</span>b[:,<span class="dv">0</span>])<span class="op">+</span>b[:,<span class="dv">0</span>], b_og[:,<span class="dv">0</span>], b_og[:,<span class="dv">1</span>])</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> Pool() <span class="im">as</span> pool: <span class="co"># evaluate solutions in parallel</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> pool.<span class="bu">map</span>(f, x)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>        sol <span class="op">=</span> x[np.argmax(y)] <span class="co"># best solution</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> f(sol) <span class="op">&gt;</span> b_f: <span class="co"># if improvement, update best solution</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>            b_f <span class="op">=</span> f(sol)<span class="op">;</span> c <span class="op">=</span> sol<span class="op">;</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">=</span> <span class="fl">0.75</span> <span class="co"># shrink search space next time</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co"># if no improvement, don't shrink search space next time (set w = 1)</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span> w <span class="op">=</span> <span class="dv">1</span> <span class="co"># increment stagnation counter</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (b_og[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">-</span>b_og[<span class="dv">0</span>,<span class="dv">0</span>])<span class="op">/</span>(b[<span class="dv">0</span>,<span class="dv">0</span>]<span class="op">-</span>b[<span class="dv">0</span>,<span class="dv">1</span>]) <span class="op">&lt;</span> <span class="fl">0.25</span> <span class="kw">or</span> count <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">'Optimised!'</span>)</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>            <span class="co"># if search space has shrunk below a threshold or not shrunk for 3 iterations</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> c <span class="co"># return best solution!</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ei(gp,x): <span class="co"># expected improvement</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    mu, var <span class="op">=</span> gp(x)<span class="op">;</span> N <span class="op">=</span> NormalDist()</span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> (mu <span class="op">-</span> np.<span class="bu">max</span>(gp.y)) <span class="op">/</span> np.sqrt(var)</span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.sqrt(var) <span class="op">*</span> (z <span class="op">*</span> N.cdf(z) <span class="op">+</span> N.pdf(z))</span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GP: <span class="co">#&nbsp;Gaussian process class</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,x,y):</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.x <span class="op">=</span> x<span class="op">;</span> <span class="va">self</span>.y <span class="op">=</span> y</span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>        <span class="co"># optimize hyperparameters (sigma, l, constant mean)</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.p <span class="op">=</span> tiny_opt(partial(nll, x<span class="op">=</span>x, y<span class="op">=</span>y), np.array([[<span class="fl">0.1</span>,<span class="fl">10.0</span>],[<span class="fl">0.1</span>,<span class="fl">10.0</span>],[np.<span class="bu">min</span>(y),np.<span class="bu">max</span>(y)]]))</span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.K_inv <span class="op">=</span> la.inv(cm(x,<span class="va">self</span>.p)) <span class="co">#&nbsp;precompute inverse covariance matrix</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>,x): </span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>        k_row <span class="op">=</span> np.array([[k(x,xi,<span class="va">self</span>.p) <span class="cf">for</span> xi <span class="kw">in</span> <span class="va">self</span>.x]]) <span class="co">#&nbsp;compute row of covariance matrix</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>        dot_prod <span class="op">=</span> np.dot(k_row,<span class="va">self</span>.K_inv) <span class="co">#&nbsp;precompute dot product</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.p[<span class="dv">2</span>] <span class="op">+</span> dot_prod.dot(<span class="va">self</span>.y<span class="op">-</span><span class="va">self</span>.p[<span class="dv">2</span>]).item(), <span class="op">\</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>            k(x,x,<span class="va">self</span>.p) <span class="op">-</span> np.dot(dot_prod,k_row.T).item()</span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">'__main__'</span>:</span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>    bounds <span class="op">=</span> np.array([[<span class="op">-</span><span class="fl">10.0</span>,<span class="fl">10.0</span>]]) </span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># sampling from prior of a GP to define test function </span></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>    x_gp <span class="op">=</span> np.linspace(bounds[<span class="dv">0</span>,<span class="dv">0</span>],bounds[<span class="dv">0</span>,<span class="dv">1</span>],<span class="dv">100</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> cm(x_gp, [<span class="fl">1.0</span>,<span class="fl">1.0</span>,<span class="fl">0.0</span>])</span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>    y_gp <span class="op">=</span> ra.multivariate_normal(np.zeros(<span class="bu">len</span>(x_gp)), K).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>    f_gp <span class="op">=</span> GP(x_gp,y_gp)<span class="op">;</span> f <span class="op">=</span> <span class="kw">lambda</span> x: f_gp(x)[<span class="dv">0</span>] <span class="co"># this now acts as my 'true' function</span></span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.linspace(bounds[<span class="dv">0</span>,<span class="dv">0</span>],bounds[<span class="dv">0</span>,<span class="dv">1</span>],<span class="dv">3</span>).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)  <span class="co"># initial training data</span></span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> np.array([f(xi) <span class="cf">for</span> xi <span class="kw">in</span> x]).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="co"># initial training data</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>    x_test <span class="op">=</span> np.array([xi <span class="cf">for</span> xi <span class="kw">in</span> np.linspace(bounds[<span class="dv">0</span>,<span class="dv">0</span>],bounds[<span class="dv">0</span>,<span class="dv">1</span>],<span class="dv">200</span>)]).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="co"># test data</span></span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a>    images <span class="op">=</span> []</span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">16</span>):</span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>        gp <span class="op">=</span> GP(x, y) <span class="co">#&nbsp;create GP</span></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>        x_opt <span class="op">=</span> tiny_opt(partial(ei,gp),bounds)<span class="op">;</span> y_opt <span class="op">=</span> ei(gp,x_opt)</span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>        mu, var <span class="op">=</span> np.array([gp(xi) <span class="cf">for</span> xi <span class="kw">in</span> x_test]).T<span class="op">;</span> std <span class="op">=</span> np.sqrt(var)</span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a>        fig,ax <span class="op">=</span> plt.subplots(<span class="dv">2</span>,<span class="dv">1</span>,figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">3</span>),sharex<span class="op">=</span><span class="va">True</span>,constrained_layout<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].set_xlabel(<span class="st">'$x$'</span>)<span class="op">;</span> ax[<span class="dv">0</span>].set_ylabel(<span class="st">'$f(x)$'</span>)<span class="op">;</span> ax[<span class="dv">1</span>].set_ylabel(<span class="st">'EI(x)'</span>)</span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>].scatter(x,y,c<span class="op">=</span><span class="st">'k'</span>,marker<span class="op">=</span><span class="st">'x'</span>)</span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>].plot(x_test, mu,c<span class="op">=</span><span class="st">'k'</span>)<span class="op">;</span> ax[<span class="dv">0</span>].plot(x_gp, y_gp,c<span class="op">=</span><span class="st">'k'</span>,ls<span class="op">=</span><span class="st">'--'</span>,alpha<span class="op">=</span><span class="fl">0.5</span>,label<span class="op">=</span><span class="st">'True Function'</span>)</span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">0</span>].fill_between(x_test.flatten(), mu<span class="op">-</span>std, mu<span class="op">+</span>std, alpha<span class="op">=</span><span class="fl">0.25</span>,lw<span class="op">=</span><span class="dv">0</span>,color<span class="op">=</span><span class="st">'k'</span>)</span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].plot(x_test, [ei(gp,xi) <span class="cf">for</span> xi <span class="kw">in</span> x_test],c<span class="op">=</span><span class="st">'k'</span>,label<span class="op">=</span><span class="st">'Expected Improvement'</span>)</span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>        ax[<span class="dv">1</span>].scatter(x_opt,y_opt,c<span class="op">=</span><span class="st">'k'</span>,marker<span class="op">=</span><span class="st">'o'</span>)</span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> ax: </span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a>            a.spines[<span class="st">'top'</span>].set_visible(<span class="va">False</span>)<span class="op">;</span> a.spines[<span class="st">'right'</span>].set_visible(<span class="va">False</span>)</span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a>            a.set_yticks([])</span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a>            a.legend(loc<span class="op">=</span><span class="st">'upper center'</span>,bbox_to_anchor<span class="op">=</span>(<span class="fl">0.5</span>,<span class="fl">1.1</span>),frameon<span class="op">=</span><span class="va">False</span>,ncol<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a>        filename <span class="op">=</span> <span class="ss">f'</span><span class="sc">{</span>_<span class="sc">:03d}</span><span class="ss">.png'</span></span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true" tabindex="-1"></a>        plt.savefig(filename,dpi<span class="op">=</span><span class="dv">300</span>)<span class="op">;</span> plt.close()</span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true" tabindex="-1"></a>        images.append(Image.<span class="bu">open</span>(filename))</span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.vstack([x,x_opt]) <span class="co"># update x </span></span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> np.vstack([y,np.array([f(x_opt[<span class="dv">0</span>])])]) <span class="co"># evaluate and update y</span></span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true" tabindex="-1"></a>    images[<span class="dv">0</span>].save(<span class="st">'bo.gif'</span>,save_all<span class="op">=</span><span class="va">True</span>,append_images<span class="op">=</span>images[<span class="dv">1</span>:],duration<span class="op">=</span><span class="dv">500</span>,loop<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<p>97 lines, not bad!</p>
<!-- ### Benchmarking

It wouldn't be fair if I ended here without a proper comparison to state-of-the-art libraries (at least in this simplified problem setting). 

I will use the default BoTorch set up from [the *Getting Started* page](https://botorch.org/#quickstart), which I think is what someone would typically do.
 -->
</section>
<section id="lessons" class="level3">
<h3 class="anchored" data-anchor-id="lessons">Lessons</h3>
<p>These things are, on the surface not that complicated. That is what makes BO as a tool so powerful. There are always a host of interesting domain-specific problems to be solved, but by demystifying BO as a whole it becomes easier to make these adjustments or developments.</p>
<p>I personally think that BO software has become overly cumbersome, but there are many moving parts, and it never quite turns out to be the one-size-fits all solution it is billed as. I don’t think there’s a long term solution or fix to this at the moment, I would only say to try it for yourself!</p>


<div class="ojs-auto-generated hidden">
<script type="ojs-module-contents">
eyJjb250ZW50cyI6WyAgeyJtZXRob2ROYW1lIjoiaW50ZXJwcmV0IiwiaW5saW5lIjoidHJ1ZSIsInNvdXJjZSI6Imh0bC5odG1sYDxzcGFuPiR7ZGVzY3JpcHRpdmVfd29yZHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGVzY3JpcHRpdmVfd29yZHMubGVuZ3RoKV19PC9zcGFuPmAiLCAiY2VsbE5hbWUiOiJvanMtZWxlbWVudC1pZC0xIn0sICB7Im1ldGhvZE5hbWUiOiJpbnRlcnByZXQiLCJpbmxpbmUiOiJ0cnVlIiwic291cmNlIjoiaHRsLmh0bWxgPHNwYW4+JHthbmltYWxzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFuaW1hbHMubGVuZ3RoKV19PC9zcGFuPmAiLCAiY2VsbE5hbWUiOiJvanMtZWxlbWVudC1pZC0yIn1dfQ==
</script>
</div>
</section>
</section>


</main> <!-- /main -->
<script type="ojs-module-contents">
eyJjb250ZW50cyI6W3sibWV0aG9kTmFtZSI6ImludGVycHJldCIsImNlbGxOYW1lIjoib2pzLWNlbGwtMSIsImlubGluZSI6ZmFsc2UsInNvdXJjZSI6ImFuaW1hbHMgPSBbXG4gICAgXCJMaW9uXCIsIFwiRWxlcGhhbnRcIiwgXCJHaXJhZmZlXCIsIFwiWmVicmFcIiwgXCJQZW5ndWluXCIsXG4gICAgXCJLYW5nYXJvb1wiLCBcIktvYWxhXCIsIFwiUGFuZGFcIiwgXCJUaWdlclwiLCBcIkRvbHBoaW5cIixcbiAgICBcIk9jdG9wdXNcIiwgXCJGbGFtaW5nb1wiLCBcIkNoZWV0YWhcIiwgXCJHb3JpbGxhXCIsIFwiU2xvdGhcIixcbiAgICBcIlBsYXR5cHVzXCIsIFwiUmhpbm9jZXJvc1wiLCBcIkNyb2NvZGlsZVwiLCBcIk93bFwiLCBcIkNoYW1lbGVvblwiLFxuICAgIFwiVG91Y2FuXCIsIFwiTWVlcmthdFwiLCBcIkhlZGdlaG9nXCIsIFwiSmVsbHlmaXNoXCIsIFwiTGVtdXJcIlxuXVxuXG5kZXNjcmlwdGl2ZV93b3JkcyA9IFtcbiAgICBcIlN3YXJtaW5nXCIsIFwiUnVubmluZ1wiLCBcIkxlYXBpbmdcIiwgXCJDcmF3bGluZ1wiLCBcIlN3aW1taW5nXCIsXG4gICAgXCJGbHlpbmdcIiwgXCJQb3VuY2luZ1wiLCBcIlNsaXRoZXJpbmdcIiwgXCJHYWxsb3BpbmdcIiwgXCJEaXZpbmdcIixcbiAgICBcIlNvYXJpbmdcIiwgXCJCdXJyb3dpbmdcIiwgXCJDbGltYmluZ1wiLCBcIkdsaWRpbmdcIiwgXCJIb3BwaW5nXCIsXG4gICAgXCJTcHJpbnRpbmdcIiwgXCJNZWFuZGVyaW5nXCIsIFwiUHJvd2xpbmdcIiwgXCJTdGFsa2luZ1wiLCBcIkNoYXJnaW5nXCIsXG4gICAgXCJEYXJ0aW5nXCIsIFwiU2N1cnJ5aW5nXCIsIFwiTHVtYmVyaW5nXCIsIFwiUHJhbmNpbmdcIiwgXCJTY2FtcGVyaW5nXCIsXG4gICAgXCJXYWRkbGluZ1wiLCBcIlppZ3phZ2dpbmdcIiwgXCJGbHV0dGVyaW5nXCIsIFwiUGFkZGxpbmdcIiwgXCJTd29vcGluZ1wiLFxuICAgIFwiTHVuZ2luZ1wiLCBcIkdyYXppbmdcIiwgXCJQZXJjaGluZ1wiLCBcIkhvdmVyaW5nXCIsIFwiQ2lyY2xpbmdcIixcbiAgICBcIk5lc3RpbmdcIiwgXCJGb3JhZ2luZ1wiLCBcIkh1bnRpbmdcIiwgXCJCb3VuZGluZ1wiLCBcIlN3aW5naW5nXCIsXG4gICAgXCJMb3VuZ2luZ1wiLCBcIkJhc2tpbmdcIiwgXCJSb29zdGluZ1wiLCBcIk1pZ3JhdGluZ1wiLCBcIkhpYmVybmF0aW5nXCIsXG4gICAgXCJDYW1vdWZsYWdpbmdcIiwgXCJNb2x0aW5nXCIsIFwiUHJlZW5pbmdcIiwgXCJGcm9saWNraW5nXCIsIFwiU3RhbXBlZGluZ1wiXG5dXG4ifV19
</script>
<script type="module">
if (window.location.protocol === "file:") { alert("The OJS runtime does not work with file:// URLs. Please use a web server to view this document."); }
window._ojs.paths.runtimeToDoc = "../../posts/bayesian_optimisation";
window._ojs.paths.runtimeToRoot = "../..";
window._ojs.paths.docToRoot = "../..";
window._ojs.selfContained = false;
window._ojs.runtime.interpretFromScriptTags();
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/sav\.phd");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="trsav/trsav.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>
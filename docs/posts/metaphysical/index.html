<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.557">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-10-17">

<title>tom savage - Metaphysical Chemical Processes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.ico" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">tom savage</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Metaphysical Chemical Processes</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 17, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<p>The Chinese room thought experiment provides an argument for why computers will never be able to truly ‚Äòthink‚Äô.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Josef Moural, ‚ÄúThe Chinese Room Argument,‚Äù in John Searle, ed.&nbsp;Barry Smith (Cambridge: Cambridge University Press, 2003), 214-260.</p></div><div id="fn2"><p><sup>2</sup>&nbsp;Margaret A. Boden, The Philosophy of Artificial Intelligence (Oxford: Oxford University Press, Inc., 1990).</p></div><div id="fn3"><p><sup>3</sup>&nbsp;I also like the implication that if the Chinese room is correct, then either the human brain with it‚Äôs electrical and chemical signals is somewhat ‚Äòspecial‚Äô and has some additional latent features that invoke consciousness/intuition/thought, <em>or</em> consciousness/intuition is actually just a bit of an illusion and there‚Äôs nothing to distinguish us from a bloke idly following instructions without understanding what they mean. Both equally fun.</p></div></div><p>In effect it states that a machine can be <em>seen</em> to be providing intelligent dialogue or conversation in Chinese, but inside ‚Äòthe room‚Äô there is simply someone with a rule book that is large enough to enumerate all the potential answers, and the rules to generate and combine them (in effect, the <em>structure</em> of Chinese). This person doesn‚Äôt truly know or think about what they are doing. Whether or not this is a realistic analogy is not something I am going to attempt to answer. To me, the Chinese room, with its counter and counter-counter-arguments<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> , is relatively convincing<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> .</p>
<p>But for the purposes of this post, I‚Äôm not convinced, I think it‚Äôs completely and utterly wrong and a bit daft.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn4"><p><sup>4</sup>&nbsp;Mind games.</p></div></div><p>Here‚Äôs a quote that I enjoy from the <a href="https://plato.stanford.edu/entries/chinese-room/">Stanford Encyclopaedia of Philosophy</a> with an interesting extension to the thought experiment.</p>
<div class="page-columns page-full"><blockquote class="blockquote">
<p>[‚Ä¶] He [Searle] suggests a variation on the brain simulator scenario: suppose that in the room the man has a huge set of valves and water pipes, in the same arrangement as the neurons in a native Chinese speaker‚Äôs brain. The program now tells the man which valves to open in response to input. Searle claims that it is obvious that there would be no understanding of Chinese. (Note however that the basis for this claim is no longer simply that Searle himself wouldn‚Äôt understand Chinese ‚Äì it seems clear that now he is just facilitating the causal operation of the system and so we rely on our Leibnizian intuition that water-works don‚Äôt understand (see also Maudlin 1989<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> ).) Searle concludes that a simulation of brain activity is not the real thing.</p>
</blockquote><div class="no-row-height column-margin column-container"><div id="fn5"><p><sup>5</sup>&nbsp;Tim Maudlin, ‚ÄúComputation and Consciousness,‚Äù The Journal of Philosophy 86, no. 8 (1989): 407-432.</p></div></div></div>
<p>It‚Äôs a good point, water-works can‚Äôt think, can they? If a brain can think, and a brain can be modelled like a series of pipes, then why can‚Äôt a series of pipes think? If I were to replace a single pipe with an actual real neuron, the signal of which controlled a valve to the next pipe, then would my water-works<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> be able to think? If I just start replacing all the pipes in my works with equivalent neurons, <em>at what point does consciousness kick in?</em></p>
<div class="no-row-height column-margin column-container"><div id="fn6"><p><sup>6</sup>&nbsp;spoiler alert, or‚Ä¶ chemical processes.</p></div><div id="fn7"><p><sup>7</sup>&nbsp;Eric Schwitzgebel, ‚ÄúIf Materialism is True, the United States is Probably Conscious,‚Äù Philosophical Studies 172, no. 7 (October 2014): 1697-1721.</p></div><div id="fn8"><p><sup>8</sup>&nbsp;This is almost certainly true when you look at Joe Biden; the US still <em>works</em> even if the man in charge is barely with us.</p></div></div><p>There‚Äôs a nice paper that touches on that last point justifying the idea that large organisations, or <em>countries</em> such as the United States can (or rather are) conscious<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> .<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<p>With that in mind, I‚Äôll get to the point. Can we design a chemical process to think?<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> The fact I‚Äôll be dealing with simulated chemical processes adds a layer of complication because we‚Äôre back to asking whether computers can think. But lets assume I‚Äôm going to end up building it.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></p>
<div class="no-row-height column-margin column-container"><div id="fn9"><p><sup>9</sup>&nbsp;Normal people will and have used neural networks to attempt this task, choosing to (originally) directly model the interactions between neurons. I‚Äôm going to choose to model the water-works, because, funny.</p></div><div id="fn10"><p><sup>10</sup>&nbsp;I might spin this off into a deep-tech unicorn.</p></div></div><section id="the-plan" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="the-plan">The Plan</h3>
<p>How am I going to go about this task? I could cheat and try to model a <em>neural network</em> using a chemical process. After all, neural networks have been proven to be universal function approximators<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> . I think this is a bit of a boring and sort of cheating. Additionally, attempting to directly find a chemical process that can reason is more interesting than finding a neural network that can reason, because I could feasibly go and build the chemical process in the real world<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> . The system it would live in is the same as us (i.e.&nbsp;not within the confines of a computer). However, in the ‚Äòlets try to get a neural network to think‚Äô-space inherently it still just exists on a computer and you‚Äôre back to square one<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> . You‚Äôd have to make the neural network into some physical representation (like a brain)<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a> . There are a host of assumptions here, namely to do with physicality, scale and permanence, but we really must move on.</p>
<div class="no-row-height column-margin column-container"><div id="fn11"><p><sup>11</sup>&nbsp;Apparently to the detriment of machine learning as a field, something about making people focus on the wrong aspects of research.</p></div><div id="fn12"><p><sup>12</sup>&nbsp;I could also build the chemical process that approximates a neural network but as I say, boring.</p></div><div id="fn13"><p><sup>13</sup>&nbsp;Or at least a less interesting metaphysical representation.</p></div><div id="fn14"><p><sup>14</sup>&nbsp;This is somewhat similar to the <a href="https://www.aria.org.uk/nature-computes-better-seeds/">ARIA project</a><em><a href="https://www.aria.org.uk/nature-computes-better-seeds/">Nature Computes Better</a></em><a href="https://www.aria.org.uk/nature-computes-better-seeds/"></a></p></div></div><p>Quite obviously, the first reasonable step to building a chemical process that can think, is to build a chemical process simulator.</p>
<p>Existing process simulators are bloated, use outdated GUIs and are not built with machine learning / data-driven workflows in mind. So I built my own. It‚Äôs currently written in Python but it might not be one day<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> . I‚Äôve called it <code>&lt;process&gt;</code>, which you <strong>have</strong> to write as a code block.</p>
<div class="no-row-height column-margin column-container"><div id="fn15"><p><sup>15</sup>&nbsp;LLM-based code-translation will solve this for me.</p></div><div id="fn16"><p><sup>16</sup>&nbsp;I can‚Äôt stress how much better and more useful this is over SFILES workflows which are outdated and stuck in an era where NLP worked on sentences and LLMs that could parse millions of tokens at a time didn‚Äôt exist. How are you seriously meant to learn a representation of something as intricate as a chemical process with an abstraction like <code>(raw)(hex)(r)[&lt;(pp)&lt;(raw)](mix)&lt;...</code>. Unless you train an LLM from scratch on SFILES (spoiler: you can‚Äôt because there is no where near enough data) they‚Äôre completely useless to use as a representation, because SFILEs are 1. not in LLM datasets (cannot truly use with pretrained LLMs) and 2. pretrained LLMs will struggle to one-shot learn what SFILES is because they‚Äôre not easily understandable, parseable or readable. LLMs are a learned representation of language, if you‚Äôre going to try and use them for chemical processes, or want a useable process representation then express them using language. SFILES rant over.</p></div><div id="fn17"><p><sup>17</sup>&nbsp;Insert OntoCAPE rant.</p></div><div id="fn18"><p><sup>18</sup>&nbsp;Apart from the silly long previous rant.</p></div><div id="fn19"><p><sup>19</sup>&nbsp;I only use TOML over YAML because it‚Äôs called <em>Tom‚Äôs Own Markup Language</em> and that is my name. These are the arbitrary decisions I have and will continue to make throughout this post.</p></div></div><p>In <code>&lt;process&gt;</code>, processes are fully represented within a TOML file. The files are detailed enough to provide a complete representation of a process<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> . The representation is also not too detailed where there would be extraneous effort to define it, reducing bloat<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> . If you‚Äôre far enough into process design that you want to model a process in significant detail then ‚Äòrigorous‚Äô tools such as Aspen or gProms are what you want anyway. <code>&lt;process&gt;</code> is not for rigorous design, it sits somewhere between SFILES<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> , and Aspen in terms of complexity. It‚Äôs main advantage over SFILES is that chemical processes can be simulated <strong>directly</strong> from an interpretable text-based .<code>toml</code> file<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> .</p>
<p><code>&lt;process&gt;</code> is effectively a compiler for chemical processes, compiling a readable text-based format into an object that can be simulated and analysed.</p>
<p>Here‚Äôs an example of the basic components of a <code>process.toml</code> file.</p>
<pre><code>[[species]]
name = "water"
molecular_weight = 18.01528 # kg/kmol
cp_poly_coeffs = [276370.0, -2090.1, 8.125, -0.014116, 9.3701e-6]
enthalpy_of_formation = -285830.0 # kJ/kmol

...

[[species]]
name = "nitro_benzene"
molecular_weight = 123.109
cp_poly_coeffs = [295300.0,-80.7,1.705]
enthalpy_of_formation = 12500.0

[[streams]]
name = "benzene_inlet"
molar_flowrate = 0.5 # kmol
molar_ratios = {benzene = 1}
temperature = 298 # K 
pressure = 101325 # Pa

...

[[streams]]
name = "benzene_recycle"
molar_flowrate = 0
molar_ratios = {benzene = 1}
temperature = 298
pressure = 101325

[[separator]]
name = "separator_one"
inlet = ["final_product"]
outlet = ["tops", "waste_water"]
spec = [{nitro_benzene= 0.95},{water= 0.95}]

...

[[mixer]]
name = "reactant_mixer"
inlet = ["benzene_inlet", "nitric_acid_inlet","recycle","benzene_recycle"]
outlet = ["reactor_reactants"]

[[reactor]]
name = "reactor_one"
inlet = ["reactor_reactants"]
outlet = ["reactor_products"]
reactant_stoichiometry = {benzene=1, nitric_acid=1}
product_stoichiometry = {water = 1, nitro_benzene =1}
conversion = {benzene=0.9}

[[splitter]]
name = "splitter_one"
inlet = ["reactor_products_cooled"]
outlet = ["final_product", "recycle"]
split_ratio = [0.8, 0.2]

[[heat_exchanger]]
name = "product_cooler"
inlet = ["reactor_products"]
outlet = ["reactor_products_cooled"]
outlet_temperature = 298</code></pre>
<p>By design, it‚Äôs relatively self-explanatory. You define molecular species, all the streams, their connections, etc. Unit operations each have specific attributes which must be defined such as the split ratio of a splitter.</p>
<p>You don‚Äôt have to specify everything<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> , <code>&lt;process&gt;</code> will attempt to simulate unit operations with specified inlet streams until the entire process converges.</p>
<div class="no-row-height column-margin column-container"><div id="fn20"><p><sup>20</sup>&nbsp;If you could then this would be a pointless tool.</p></div></div><p>Degrees-of-freedom are currently quite uncompromising. There is no way to fix a stream, and every variable can be changed. There is no need for a specific ‚Äòrecycle‚Äô block or stream due to the way a process is converged. At the expense of bloat, you have to pay slightly more attention to what is being defined, which is not the worst trade off.</p>
<p>Anyway, I might write this up a bit longer at some point depending if I flesh it out a bit. For now, onwards‚Ä¶ I can visualise a process as follows:</p>
<pre><code>process_file = "nitrobenzene_process.toml"
process = parse_process(process_file)
process.plot("outputs/process.png")</code></pre>
<div class="center">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="1.png" class="img-fluid figure-img" style="width:60.0%"></p>
<figcaption>A visualised process.</figcaption>
</figure>
</div>
</div>
<p>And simulate it as so:</p>
<pre><code>process.simulate(tol=1e-7)
process.plot_convergence("outputs/convergence.png")


Stream Tolerance -&gt; 2.20e+00 -&gt; 5.29e-01 -&gt; 1.12e-01 -&gt;...-&gt; 9.47e-07 -&gt; 3.83e-07 -&gt; 1.54e-07
Converged in 30 iterations.</code></pre>
<div class="center">
<p><img src="2.png" class="img-fluid" style="width:60.0%"></p>
</div>
<p>The overall mass and energy balance can be validated<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a> , and I can also print off the steady-state of the converged process.</p>
<div class="no-row-height column-margin column-container"><div id="fn21"><p><sup>21</sup>&nbsp;This is done by analysing streams to see if they come from, or go to a unit operation. If not, they are designated process inlet or outlets and quantities summed.</p></div></div><pre><code>print(process, '\n')
print(process.confirm_energy_balance(), '\n')
print(process.confirm_mass_balance())


Process(name='nitrobenzene_process', unit_operations={'reactant_mixer': Mixer(name='reactant_mixer', inlet=[(0.50 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '1.00'}, (0.50 kmol/hr, 312.00 K, 101325.00 Pa) {'nitric_acid': '1.00'}, (0.26 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}, (0.04 kmol/hr, 298.00 K, 101325.00 Pa) {'nitric_acid': '0.17', 'water': '0.28', 'nitro_benzene': '0.10', 'benzene': '0.45'}], outlet=[(1.31 kmol/hr, 300.92 K, 101325.00 Pa) {'benzene': '0.41', 'nitric_acid': '0.39', 'water': '0.10', 'nitro_benzene': '0.10'}], process=...), 'splitter_one': Splitter(name='splitter_one', inlet=[(1.31 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}], outlet=[(1.04 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}, (0.26 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}], process=..., split_ratio=[0.8, 0.2]), 'reactor_one': Reactor(name='reactor_one', inlet=[(1.31 kmol/hr, 300.92 K, 101325.00 Pa) {'benzene': '0.41', 'nitric_acid': '0.39', 'water': '0.10', 'nitro_benzene': '0.10'}], outlet=[(1.31 kmol/hr, 367.04 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}], process=..., reactant_stoichiometry={'benzene': 1, 'nitric_acid': 1}, product_stoichiometry={'water': 1, 'nitro_benzene': 1}, conversion={'benzene': 0.9}, heat_of_reaction=153180.0), 'product_cooler': HeatExchanger(name='product_cooler', inlet=[(1.31 kmol/hr, 367.04 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}], outlet=[(1.31 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}], process=..., outlet_temperature=298, delta_temperature=None), 'separator_one': Separator(name='separator_one', inlet=[(1.04 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}], outlet=[(0.52 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'nitro_benzene': '0.88', 'water': '0.05'}, (0.53 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'nitro_benzene': '0.05', 'water': '0.89'}], process=..., spec=[{'nitro_benzene': 0.95}, {'water': 0.95}]), 'separator_two': Separator(name='separator_two', inlet=[(0.52 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'nitro_benzene': '0.88', 'water': '0.05'}], outlet=[(0.47 kmol/hr, 298.00 K, 101325.00 Pa) {'nitric_acid': '0.02', 'water': '0.03', 'nitro_benzene': '0.96', 'benzene': '0.00'}, (0.04 kmol/hr, 298.00 K, 101325.00 Pa) {'nitric_acid': '0.17', 'water': '0.28', 'nitro_benzene': '0.10', 'benzene': '0.45'}], process=..., spec=[{'nitro_benzene': 0.99}, {'benzene': 0.95}])}, streams={'benzene_inlet': (0.50 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '1.00'}, 'nitric_acid_inlet': (0.50 kmol/hr, 312.00 K, 101325.00 Pa) {'nitric_acid': '1.00'}, 'reactor_products': (1.31 kmol/hr, 367.04 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}, 'reactor_products_cooled': (1.31 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}, 'reactor_reactants': (1.31 kmol/hr, 300.92 K, 101325.00 Pa) {'benzene': '0.41', 'nitric_acid': '0.39', 'water': '0.10', 'nitro_benzene': '0.10'}, 'final_product': (1.04 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}, 'tops': (0.52 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'nitro_benzene': '0.88', 'water': '0.05'}, 'waste_water': (0.53 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'nitro_benzene': '0.05', 'water': '0.89'}, 'pure_product': (0.47 kmol/hr, 298.00 K, 101325.00 Pa) {'nitric_acid': '0.02', 'water': '0.03', 'nitro_benzene': '0.96', 'benzene': '0.00'}, 'benzene_recycle': (0.04 kmol/hr, 298.00 K, 101325.00 Pa) {'nitric_acid': '0.17', 'water': '0.28', 'nitro_benzene': '0.10', 'benzene': '0.45'}, 'recycle': (0.26 kmol/hr, 298.00 K, 101325.00 Pa) {'benzene': '0.04', 'nitric_acid': '0.03', 'water': '0.47', 'nitro_benzene': '0.46'}}, species={'water': water (18.01528 kg/kmol), 'benzene': benzene (78.11 kg/kmol), 'nitric_acid': nitric_acid (63.013 kg/kmol), 'nitro_benzene': nitro_benzene (123.109 kg/kmol)}, print=True, simulated_at=datetime.datetime(2024, 8, 18, 15, 26, 8, 154480, tzinfo=datetime.timezone.utc)) 

Enthalpy in: 37412.944 kJ,  Reaction Enthalpy: 73175.159 kJ, Enthalpy Added: -38052.065 kJ, Enthalpy out: 72536.082 kJ
Difference: -0.043281 kJ (-0.000116%)
False 

Mass in: 70.561 kg, Mass out: 70.562 kg
Difference: -0.000613 kg (-0.000869%)
True</code></pre>
<p>I can simulate heat exchangers, splitting streams, mixing streams, basic separations, non-adiabatic reactions with stoichiometric ratios, components with specific heat capacities as a function of temperature‚Ä¶ this should be enough for now.</p>
</section>
<section id="what-was-that-about-anyway" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="what-was-that-about-anyway">What was that about? Anyway‚Ä¶</h3>
<p>The goal here is to build an input-output machine, that on the surface acts like the ‚Äòroom‚Äô in the Chinese room, and more precisely, the waterworks within the room as proposed by Searle in his brain simulator scenario. To make this easier, when I say ‚Äòthink‚Äô, I mean I‚Äôm going to approximate a function, because as I previously mention, I don‚Äôt believe in the Chinese room argument.</p>
<p>I will go about doing this through <strong>direct simulation</strong>, where the chemical process is directly used to model a function via something analogous to symbolic regression or evolutionary programming^[Alternative methods would be to either:</p>
<p>1. Build up the basic building blocks of computation, i.e.&nbsp;AND, OR, gates etc‚Ä¶ Then by extension demonstrate how a computer can be constructed, and therefore a universal function approximator (2 layers of abstraction below thinking). Or‚Ä¶</p>
<p>2. Build up the basic building blocks of a neural network, which, as a universal function approximator, completes the ability to approximate functions (1 layer of abstraction below thinking).</p>
<p>But as previously mentioned, I want the chemical process to be as close as possible to the function approximation task at hand.] .</p>
<p>Therefore, the mathematical problem I will solve will be a least-squares (machine learning) task over chemical processes:</p>
<p><span class="math display">\[\min_{\mathcal{P}} \sum_{i=1}^N ||\mathcal{P}(x_i) - y_i||^2_2\]</span></p>
<p>where a chemical process ùí´ is defined by a set of unit operations ùí™, connecting streams ùíÆ, yappa yappa blah blah blah‚Ä¶ Basically, you choose what the input x represents in your process, and what the output y represents. Simulate the chemical process for a given x and evaluate the output. Do this for all values of x in the dataset and you can evaluate how well the process approximates the function.</p>
<p>That being said, I am going to solve this optimisation problem using evolutionary programming, a benefit of using <code>&lt;process&gt;</code>. Firstly, I‚Äôll demonstrate a way of evaluating the objective function.</p>
<p>To begin with I will define a very basic process with a single component as an inlet stream, a single component as an outlet stream, and a mixer that doesn‚Äôt do anything.</p>
<pre><code>[[species]]
name = "water"
molecular_weight = 18.01528 # kg/kmol
cp_poly_coeffs = [276370.0, -2090.1, 8.125, -0.014116, 9.3701e-6]
enthalpy_of_formation = -285830.0 # kJ/kmol

[[streams]]
name = "inlet"
molar_flowrate = 0.5 # kmol
molar_ratios = {water = 1}
temperature = 298 # K 
pressure = 101325 # Pa

[[streams]]
name = "outlet"

[[mixer]]
name = "mixer"
inlet = ["inlet"]
outlet = ["outlet"]</code></pre>
<div class="center">
<p><img src="3.png" class="img-fluid" style="width:60.0%"></p>
</div>
<p>For now, assuming temperature of both the inlet stream and outlet stream represent my functional input and output respectively, I can simulate the process and evaluate the objective function as follows:</p>
<pre><code>y_test = []
for i in range(n):
    process.streams['inlet'].temperature = x[i]
    process.simulate(tol=1e-7)
    y_test.append(process.streams['outlet'].temperature)</code></pre>
<div class="center">
<p><img src="4.png" class="img-fluid" style="width:60.0%"></p>
</div>
<p>Can you see where we‚Äôre going yet? I can take advantage of multiprocessing to evaluate the objective function in parallel. This is a strength of <code>&lt;process&gt;</code>, and is a good demonstration of designing something like a process simulator with machine learning use cases in mind.</p>
<p>I‚Äôll assume that physical units can be scaled later on. Now I can hypothesise that there is a heat exchanger between the streams, with a given temperature decrease to get a different ‚Äòloss‚Äô between our data and the process output.</p>
<pre><code>[[heat_exchanger]]
name = "product_cooler"
inlet = ["inlet"]
outlet = ["outlet"]
delta_temperature = -3 # K</code></pre>
<div class="center">
<p><img src="5.png" class="img-fluid" style="width:60.0%"></p>
</div>
<p>I‚Äôll stop here, we get the idea. We can change the type of unit operation, their internal parameters, and their order to try and approximate a function. Now we have the ability to:</p>
<ol type="1">
<li><p>Evaluate how well our process can approximate a function;</p></li>
<li><p>Mutate the process<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a> .</p></li>
</ol>
<div class="no-row-height column-margin column-container"><div id="fn22"><p><sup>22</sup>&nbsp;Once again, by building a lightweight process simulator we have gained the ability to easily modify the process structure enabling us to solve an optimisation problem over different structures, something that takes PhD lengths of time to do in Aspen or gProms.</p></div><div id="fn23"><p><sup>23</sup>&nbsp;Presented in an unnecessarily complex amount of detail, remember?</p></div></div><p>We can build a basic evolutionary programming framework to solve the optimisation problem above<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a> , acting like a sort of growing neural network, with feedback.</p>
<p>But that will have to wait‚Ä¶. for next time!</p>


</section>


</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/sav\.phd");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="trsav/trsav.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>